/*
 * dns.c — DNS resolv.conf management for mqvpn client
 */
#include "dns.h"
#include "log.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>

void
mqvpn_dns_init(mqvpn_dns_t *dns)
{
    memset(dns, 0, sizeof(*dns));
    dns->resolv_path = "/etc/resolv.conf";
    dns->backup_path = "/etc/resolv.conf.mqvpn.bak";
}

int
mqvpn_dns_add_server(mqvpn_dns_t *dns, const char *addr)
{
    if (dns->n_servers >= MQVPN_DNS_MAX_SERVERS) {
        LOG_WRN("dns: max %d servers supported", MQVPN_DNS_MAX_SERVERS);
        return -1;
    }
    snprintf(dns->servers[dns->n_servers], sizeof(dns->servers[0]), "%s", addr);
    dns->n_servers++;
    return 0;
}

/* Copy file src to dst */
static int
copy_file(const char *src, const char *dst)
{
    FILE *in = fopen(src, "r");
    if (!in) return -1;
    FILE *out = fopen(dst, "w");
    if (!out) {
        fclose(in);
        return -1;
    }
    char buf[4096];
    size_t n;
    while ((n = fread(buf, 1, sizeof(buf), in)) > 0) {
        if (fwrite(buf, 1, n, out) != n) {
            fclose(in);
            fclose(out);
            return -1;
        }
    }
    fclose(in);
    fclose(out);
    return 0;
}

int
mqvpn_dns_apply(mqvpn_dns_t *dns)
{
    if (dns->n_servers == 0) {
        return 0; /* nothing to do */
    }

    /* Check for systemd-resolved symlink */
    struct stat st;
    if (lstat(dns->resolv_path, &st) == 0 && S_ISLNK(st.st_mode)) {
        LOG_WRN("dns: %s is a symlink (possibly systemd-resolved). "
                "Overwriting anyway.", dns->resolv_path);
    }

    /* Backup original resolv.conf */
    if (copy_file(dns->resolv_path, dns->backup_path) < 0) {
        LOG_WRN("dns: could not backup %s (file may not exist)",
                dns->resolv_path);
        /* Continue anyway — new installation may not have resolv.conf */
    }

    /* Write new resolv.conf */
    FILE *fp = fopen(dns->resolv_path, "w");
    if (!fp) {
        LOG_ERR("dns: cannot write %s: %m", dns->resolv_path);
        return -1;
    }

    fprintf(fp, "# Generated by mqvpn — do not edit\n");
    fprintf(fp, "# Original saved to %s\n", dns->backup_path);
    for (int i = 0; i < dns->n_servers; i++) {
        fprintf(fp, "nameserver %s\n", dns->servers[i]);
    }
    fclose(fp);

    dns->active = 1;
    LOG_INF("dns: configured %d server(s), backed up to %s",
            dns->n_servers, dns->backup_path);
    return 0;
}

void
mqvpn_dns_restore(mqvpn_dns_t *dns)
{
    if (!dns->active) return;

    if (copy_file(dns->backup_path, dns->resolv_path) < 0) {
        LOG_ERR("dns: failed to restore %s from %s",
                dns->resolv_path, dns->backup_path);
        return;
    }

    unlink(dns->backup_path);
    dns->active = 0;
    LOG_INF("dns: restored %s", dns->resolv_path);
}

int
mqvpn_dns_has_stale_backup(const mqvpn_dns_t *dns)
{
    return access(dns->backup_path, F_OK) == 0;
}

void
mqvpn_dns_restore_stale(mqvpn_dns_t *dns)
{
    if (!mqvpn_dns_has_stale_backup(dns)) return;

    LOG_WRN("dns: stale backup found at %s, restoring", dns->backup_path);
    if (copy_file(dns->backup_path, dns->resolv_path) < 0) {
        LOG_ERR("dns: failed to restore from stale backup");
        return;
    }
    unlink(dns->backup_path);
    LOG_INF("dns: restored %s from stale backup", dns->resolv_path);
}
